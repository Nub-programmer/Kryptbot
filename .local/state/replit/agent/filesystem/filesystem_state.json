{"file_contents":{"nonononnonono/BOTCRYPTIC/kryptix/src/utils/validation.js":{"content":"function validateHuntData(huntData) {\n        const errors = [];\n        if (!huntData || typeof huntData !== \"object\") {\n                errors.push(\"Hunt data must be a valid JSON object\");\n                return errors;\n        }\n\n        if (!huntData.name || typeof huntData.name !== \"string\") {\n                errors.push(\"Hunt must have a valid 'name' field\");\n        }\n\n        if (!huntData.levels || !Array.isArray(huntData.levels)) {\n                errors.push(\"Hunt must have a 'levels' array\");\n                return errors;\n        }\n\n        if (huntData.levels.length === 0) {\n                errors.push(\"Hunt must have at least one level\");\n                return errors;\n        }\n\n        if (huntData.levels.length > 100) {\n                errors.push(\"Hunt cannot have more than 100 levels\");\n        }\n\n        const levelIds = new Set();\n        huntData.levels.forEach((level, index) => {\n                const levelPrefix = `Level ${index + 1}`;\n                if (!level.id || typeof level.id !== \"number\") {\n                        errors.push(`${levelPrefix}: Must have a valid numeric 'id' field`);\n                } else {\n                        if (levelIds.has(level.id)) {\n                                errors.push(`${levelPrefix}: Duplicate level ID ${level.id}`);\n                        }\n                        levelIds.add(level.id);\n\n                        if (level.id < 1 || level.id > 1000) {\n                                errors.push(`${levelPrefix}: Level ID must be between 1 and 1000`);\n                        }\n                }\n\n                if (!level.question || typeof level.question !== \"string\") {\n                        errors.push(`${levelPrefix}: Must have a valid 'question' field`);\n                } else if (level.question.length > 2000) {\n                        errors.push(`${levelPrefix}: Question cannot exceed 2000 characters`);\n                }\n\n                if (!level.answer) {\n                        errors.push(`${levelPrefix}: Must have an 'answer' field`);\n                } else {\n                        if (Array.isArray(level.answer)) {\n                                if (level.answer.length === 0) {\n                                        errors.push(`${levelPrefix}: Answer array cannot be empty`);\n                                } else {\n                                        level.answer.forEach((ans, ansIndex) => {\n                                                if (typeof ans !== \"string\" || ans.trim() === \"\") {\n                                                        errors.push(\n                                                                `${levelPrefix}: Answer ${ansIndex + 1} must be a non-empty string`,\n                                                        );\n                                                }\n                                        });\n                                }\n                        } else if (\n                                typeof level.answer !== \"string\" ||\n                                level.answer.trim() === \"\"\n                        ) {\n                                errors.push(\n                                        `${levelPrefix}: Answer must be a non-empty string or array of strings`,\n                                );\n                        }\n                }\n\n                if (level.hint && typeof level.hint !== \"string\") {\n                        errors.push(`${levelPrefix}: Hint must be a string`);\n                } else if (level.hint && level.hint.length > 1000) {\n                        errors.push(`${levelPrefix}: Hint cannot exceed 1000 characters`);\n                }\n\n                if (\n                        level.points &&\n                        (typeof level.points !== \"number\" ||\n                                level.points < 1 ||\n                                level.points > 10000)\n                ) {\n                        errors.push(\n                                `${levelPrefix}: Points must be a number between 1 and 10000`,\n                        );\n                }\n\n                if (level.image && typeof level.image !== \"string\") {\n                        errors.push(`${levelPrefix}: Image must be a valid URL string`);\n                }\n        });\n\n        return errors;\n}\n\nmodule.exports = { validateHuntData };\n","path":null,"size_bytes":4350,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/replit.md":{"content":"# KryptixBot - Discord Cryptic Hunt Bot\n\n## Overview\n\nKryptixBot is a Discord bot that enables server administrators to create and run custom cryptic hunts (puzzle/riddle competitions) within their Discord servers. Players progress through sequential levels by solving riddles, puzzles, and cryptographic challenges. The bot tracks individual progress, awards points, provides hints with penalties, and maintains server-wide leaderboards.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Core Technology Stack\n\n**Runtime Environment**\n- Node.js v16+ with JavaScript\n- Discord.js v14.18.0 for Discord API interactions\n- SQLite3 v5.1.7 for local data persistence\n- dotenv v17.2.0 for environment configuration\n\n**Architectural Pattern**\n\nThe application follows a modular, event-driven architecture organized around Discord bot patterns:\n\n**Entry Point** (`index.js`)\n- Minimal bootstrap layer that initializes database connections\n- Registers Discord event listeners (ready, interactionCreate, messageCreate)\n- Implements graceful shutdown handlers for SIGINT, SIGTERM, and uncaught exceptions\n- Ensures database cleanup on process exit\n\n**Modular Organization** (`src/` directory structure)\n- `client.js`: Discord client initialization with gateway intents (Guilds, GuildMessages, MessageContent)\n- `config/`: Centralized configuration management using environment variables and owner whitelist\n- `database/`: Database connection pooling and all CRUD operations\n- `commands/`: Slash command definitions using Discord.js SlashCommandBuilder pattern\n- `handlers/`: Event handlers separated by interaction type (slash commands vs prefix commands)\n- `utils/`: Validation logic and permission checking utilities\n- `data/`: Static gamification content (trivia challenges, hint examples)\n\n**Event-Driven Design**\n\nThe bot responds to three primary Discord events:\n1. `ready`: One-time initialization for command registration\n2. `interactionCreate`: Handles slash commands and button interactions (player-facing features)\n3. `messageCreate`: Handles prefix commands (admin-only features with `k` prefix)\n\n**Command Architecture**\n\nTwo distinct command systems serve different user roles:\n\n*Slash Commands (Player & Admin)*\n- `/hunt` - Display current level question\n- `/answer` - Submit answer for current level\n- `/hint` - Request hint with point penalty\n- `/leaderboard` - View server rankings\n- `/progress` - Check personal progress\n- `/previous` - View completed questions\n- `/setup-hunt` - Admin: Upload hunt JSON file\n- `/hunt-status` - Check active hunt status\n- `/help` - Display bot usage information\n\n*Prefix Commands (Owner-only)*\n- `k!help` - Admin command reference\n- `k!answers` - View all answers for debugging\n- `k!leads` - Display hint strategy examples\n- `k!fun` - Show gamification activities\n- `k!add <user> <points>` - Manually adjust user points\n\n**Permission Model**\n\nThree-tier permission system:\n1. **Bot Owners**: Hardcoded whitelist in `owners.json` (5 users) with access to prefix commands\n2. **Server Administrators**: Users with Administrator permission or server ownership can use `/setup-hunt`\n3. **Players**: All users can access gameplay slash commands\n\n### Data Storage Architecture\n\n**SQLite Database** (`data/hunt.db`)\n\nThe application uses a single-file SQLite database with the following schema:\n\n**Tables**\n\n1. `guild_hunts` - Hunt configurations per Discord server\n   - `guild_id` (PRIMARY KEY): Discord server identifier\n   - `hunt_data` (TEXT/JSON): Complete hunt structure (questions, answers, hints, points)\n   - `created_by` (TEXT): User ID who created the hunt\n   - `created_at` (INTEGER): Unix timestamp\n   - `active` (INTEGER): Boolean flag (1 = active, 0 = inactive)\n\n2. `user_progress` - Individual player progress tracking\n   - `user_id` (TEXT): Discord user identifier\n   - `guild_id` (TEXT): Discord server identifier\n   - `level` (INTEGER): Current level number\n   - `points` (INTEGER): Total points earned\n   - `hint_used` (TEXT): Comma-separated list of levels where hints were used\n   - `start_time` (INTEGER): Unix timestamp of hunt start\n   - PRIMARY KEY: (user_id, guild_id)\n\n3. `completed_levels` - History of completed levels\n   - `user_id` (TEXT): Discord user identifier\n   - `guild_id` (TEXT): Discord server identifier\n   - `level_id` (INTEGER): Completed level number\n   - `completed_at` (INTEGER): Unix timestamp\n   - `points_earned` (INTEGER): Points awarded for this level\n   - FOREIGN KEY: (user_id, guild_id) references user_progress\n\n4. `leaderboard` - Cached leaderboard data\n   - `user_id` (TEXT): Discord user identifier\n   - `guild_id` (TEXT): Discord server identifier\n   - `username` (TEXT): Display name\n   - `points` (INTEGER): Total points\n   - `level` (INTEGER): Current level\n   - `start_time` (INTEGER): Hunt start timestamp\n   - `last_completed` (INTEGER): Last completion timestamp\n   - PRIMARY KEY: (user_id, guild_id)\n\n**Data Flow**\n\nHunt creation flow:\n1. Admin uploads JSON file via `/setup-hunt`\n2. Validation checks structure, field types, and constraints\n3. Hunt data stored as serialized JSON in `guild_hunts` table\n4. Previous hunt data (if any) is deleted, resetting all player progress\n\nGameplay flow:\n1. Player uses `/hunt` to retrieve current question from hunt JSON\n2. Player submits answer via `/answer`\n3. Answer validation (case-insensitive, supports multiple correct answers)\n4. On correct answer:\n   - `user_progress` updated (increment level, add points)\n   - `completed_levels` record inserted\n   - `leaderboard` cache updated\n5. On wrong answer: No state change, player retries\n\n**Hunt Data Format**\n\nHunts are defined in JSON files with this structure:\n```json\n{\n  \"name\": \"Hunt Name\",\n  \"description\": \"Hunt description\",\n  \"levels\": [\n    {\n      \"id\": 1,\n      \"question\": \"Question text\",\n      \"answer\": [\"answer1\", \"answer2\"],  // Array or single string\n      \"hint\": \"Hint text\",\n      \"points\": 100,\n      \"image\": \"https://optional-image-url.com/image.png\"\n    }\n  ]\n}\n```\n\n**Validation Rules**\n- Maximum 100 levels per hunt\n- Level IDs must be unique and between 1-1000\n- Questions limited to 2000 characters\n- Answers can be array (multiple accepted answers) or string (single answer)\n- Points must be positive integers\n- Image URLs optional\n\n### Game Mechanics\n\n**Hint System**\n\nDynamic penalty calculation:\n- Base penalty: 20% of level points\n- Scaling penalty: +5% per level (capped at 50%)\n- Formula: `min(20 + (level - 1) * 5, 50)%`\n- Hints tracked per-user to prevent multiple penalties on same level\n\n**Point System**\n- Points defined per level in hunt JSON\n- Reduced by hint penalty if hint requested\n- Manually adjustable by bot owners via `k!add` command\n- Leaderboard ranked by total points (tiebreaker: completion time)\n\n**Progress Tracking**\n- Linear progression (must complete levels sequentially)\n- Cannot skip levels\n- Can view previous questions via `/previous`\n- Hunt completion requires finishing all defined levels\n\n## External Dependencies\n\n### Third-Party Services\n\n**Discord Platform**\n- Discord API via discord.js library\n- Requires bot token from Discord Developer Portal\n- Uses Gateway v10 with three intents: Guilds, GuildMessages, MessageContent\n- Slash commands registered globally via REST API\n\n### Runtime Dependencies\n\n**Production Dependencies**\n- `discord.js` (v14.18.0): Discord API client library with builders, collections, and REST utilities\n- `sqlite3` (v5.1.7): Native SQLite3 bindings for Node.js\n- `dotenv` (v17.2.0): Environment variable loader from `.env` file\n\n**Development Dependencies**\n- `nodemon` (v3.1.9): Auto-restart development server on file changes\n- `typescript` (v5.2.2): Type definitions (unused in current JavaScript codebase)\n\n### Configuration Requirements\n\n**Environment Variables** (`.env` file)\n- `DISCORD_TOKEN`: Bot authentication token from Discord Developer Portal\n\n**Static Configuration** (`src/config/owners.json`)\n- Hardcoded list of bot owner Discord user IDs with admin privileges\n- Currently contains 5 whitelisted users\n\n### File System Dependencies\n\n**Database Storage**\n- SQLite database file located at `data/hunt.db`\n- Created automatically if missing\n- Requires read/write permissions\n\n**Hunt Definition Files**\n- JSON files uploaded as Discord attachments\n- Parsed and validated before storage\n- Examples provided: `example-hunt.json`, `hunt.json`","path":null,"size_bytes":8404,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/src/database/operations.js":{"content":"const { db } = require(\"./connection\");\n\nasync function safeop(operation, errorMessage = \"Database operation failed\") {\n        try {\n                return await operation();\n        } catch (error) {\n                console.error(`${errorMessage}:`, error);\n                return null;\n        }\n}\n\nasync function ensureLeaderboardTable() {\n        return new Promise((resolve) => {\n                db.get(\n                        \"SELECT name FROM sqlite_master WHERE type='table' AND name='leaderboard'\",\n                        (err, row) => {\n                                if (err || !row) {\n                                        console.log(\"Leaderboard table missing, creating it now...\");\n                                        db.run(\n                                                `CREATE TABLE IF NOT EXISTS leaderboard (\n                                                user_id TEXT,\n                                                guild_id TEXT,\n                                                username TEXT,\n                                                points INTEGER,\n                                                level INTEGER,\n                                                start_time INTEGER,\n                                                last_completed INTEGER,\n                                                PRIMARY KEY (user_id, guild_id)\n                                        )`,\n                                                (err) => {\n                                                        if (err) {\n                                                                console.error(\"Error creating leaderboard table:\", err);\n                                                        } else {\n                                                                console.log(\"Leaderboard table created successfully\");\n                                                        }\n                                                        resolve();\n                                                },\n                                        );\n                                } else {\n                                        db.all(\"PRAGMA table_info(leaderboard)\", (err, columns) => {\n                                                if (err) {\n                                                        console.error(\"Error checking leaderboard structure:\", err);\n                                                        resolve();\n                                                        return;\n                                                }\n\n                                                const requiredColumns = [\n                                                        \"user_id\",\n                                                        \"guild_id\",\n                                                        \"username\",\n                                                        \"points\",\n                                                        \"level\",\n                                                        \"start_time\",\n                                                        \"last_completed\",\n                                                ];\n                                                const existingColumns = columns.map((col) => col.name);\n                                                const missingColumns = requiredColumns.filter(\n                                                        (col) => !existingColumns.includes(col),\n                                                );\n\n                                                if (missingColumns.length > 0) {\n                                                        console.log(\n                                                                `Leaderboard table missing columns: ${missingColumns.join(\", \")}, recreating...`,\n                                                        );\n                                                        db.run(\"DROP TABLE leaderboard\", (err) => {\n                                                                if (err) console.error(\"Error dropping old leaderboard:\", err);\n\n                                                                db.run(\n                                                                        `CREATE TABLE leaderboard (\n                                                                        user_id TEXT,\n                                                                        guild_id TEXT,\n                                                                        username TEXT,\n                                                                        points INTEGER,\n                                                                        level INTEGER,\n                                                                        start_time INTEGER,\n                                                                        last_completed INTEGER,\n                                                                        PRIMARY KEY (user_id, guild_id)\n                                                                )`,\n                                                                        (err) => {\n                                                                                if (err) {\n                                                                                        console.error(\"Error recreating leaderboard table:\", err);\n                                                                                } else {\n                                                                                        console.log(\"Leaderboard table recreated successfully\");\n                                                                                }\n                                                                                resolve();\n                                                                        },\n                                                                );\n                                                        });\n                                                } else {\n                                                        resolve();\n                                                }\n                                        });\n                                }\n                        },\n                );\n        });\n}\n\nasync function cleanupDatabaseState() {\n        return new Promise((resolve) => {\n                db.run(\"DROP TABLE IF EXISTS user_progress_backup\", () => {\n                        db.run(\"DROP TABLE IF EXISTS completed_levels_backup\", () => {\n                                db.run(\"DROP TABLE IF EXISTS leaderboard_backup\", () => {\n                                        resolve();\n                                });\n                        });\n                });\n        });\n}\n\nasync function getGuildHunt(guildId) {\n        return safeop(\n                () =>\n                        new Promise((resolve, reject) => {\n                                db.get(\n                                        \"SELECT * FROM guild_hunts WHERE guild_id = ? AND active = 1\",\n                                        [guildId],\n                                        (err, row) => {\n                                                if (err) reject(err);\n                                                if (!row) resolve(null);\n                                                else {\n                                                        try {\n                                                                const huntData = JSON.parse(row.hunt_data);\n                                                                resolve({ ...row, huntData });\n                                                        } catch (parseErr) {\n                                                                reject(parseErr);\n                                                        }\n                                                }\n                                        },\n                                );\n                        }),\n                \"Error fetching guild hunt\",\n        );\n}\n\nasync function createGuildHunt(guildId, huntData, createdBy) {\n        await cleanupDatabaseState();\n\n        return safeop(\n                () =>\n                        new Promise((resolve, reject) => {\n                                db.run(\n                                        \"INSERT OR REPLACE INTO guild_hunts (guild_id, hunt_data, created_by, created_at, active) VALUES (?, ?, ?, ?, 1)\",\n                                        [guildId, JSON.stringify(huntData), createdBy, Date.now()],\n                                        (err) => {\n                                                if (err) reject(err);\n                                                else resolve(true);\n                                        },\n                                );\n                        }),\n                \"Error creating guild hunt\",\n        );\n}\n\nasync function deleteGuildHunt(guildId) {\n        await ensureLeaderboardTable();\n\n        return safeop(\n                () =>\n                        new Promise((resolve, reject) => {\n                                db.serialize(() => {\n                                        db.run(\"BEGIN TRANSACTION\", (err) => {\n                                                if (err) {\n                                                        reject(err);\n                                                        return;\n                                                }\n\n                                                const deleteOperations = [\n                                                        \"DELETE FROM completed_levels WHERE guild_id = ?\",\n                                                        \"DELETE FROM user_progress WHERE guild_id = ?\",\n                                                        \"DELETE FROM leaderboard WHERE guild_id = ?\",\n                                                        \"DELETE FROM guild_hunts WHERE guild_id = ?\",\n                                                ];\n\n                                                let hasError = false;\n\n                                                const executeNextDelete = (index) => {\n                                                        if (index >= deleteOperations.length) {\n                                                                db.run(\"COMMIT\", (err) => {\n                                                                        if (err) {\n                                                                                db.run(\"ROLLBACK\");\n                                                                                reject(err);\n                                                                        } else {\n                                                                                resolve(true);\n                                                                        }\n                                                                });\n                                                                return;\n                                                        }\n\n                                                        db.run(deleteOperations[index], [guildId], (err) => {\n                                                                if (err) {\n                                                                        console.error(`Error in delete operation ${index}:`, err);\n                                                                        if (!hasError) {\n                                                                                hasError = true;\n                                                                                db.run(\"ROLLBACK\");\n                                                                                reject(err);\n                                                                        }\n                                                                        return;\n                                                                }\n                                                                executeNextDelete(index + 1);\n                                                        });\n                                                };\n\n                                                executeNextDelete(0);\n                                        });\n                                });\n                        }),\n                \"Error deleting guild hunt\",\n        );\n}\n\nasync function getUserProgress(userId, guildId) {\n        return safeop(\n                () =>\n                        new Promise((resolve, reject) => {\n                                db.get(\n                                        \"SELECT * FROM user_progress WHERE user_id = ? AND guild_id = ?\",\n                                        [userId, guildId],\n                                        async (err, row) => {\n                                                if (err) reject(err);\n                                                if (!row) {\n                                                        const newUser = {\n                                                                level: 1,\n                                                                points: 0,\n                                                                hintUsed: [],\n                                                                startTime: Date.now(),\n                                                        };\n                                                        const success = await initializeUser(userId, guildId, newUser);\n                                                        if (success) resolve(newUser);\n                                                        else reject(new Error(\"Failed to initialize user\"));\n                                                } else {\n                                                        try {\n                                                                row.hintUsed = JSON.parse(row.hint_used || \"[]\");\n                                                                resolve(row);\n                                                        } catch (parseErr) {\n                                                                console.error(\"Error parsing hint_used:\", parseErr);\n                                                                row.hintUsed = [];\n                                                                resolve(row);\n                                                        }\n                                                }\n                                        },\n                                );\n                        }),\n                \"Error fetching user progress\",\n        );\n}\n\nasync function initializeUser(userId, guildId, data) {\n        return (\n                safeop(\n                        () =>\n                                new Promise((resolve, reject) => {\n                                        db.run(\n                                                \"INSERT INTO user_progress (user_id, guild_id, level, points, hint_used, start_time) VALUES (?, ?, ?, ?, ?, ?)\",\n                                                [\n                                                        userId,\n                                                        guildId,\n                                                        data.level,\n                                                        data.points,\n                                                        JSON.stringify(data.hintUsed),\n                                                        data.startTime,\n                                                ],\n                                                (err) => {\n                                                        if (err) reject(err);\n                                                        else resolve(true);\n                                                },\n                                        );\n                                }),\n                        \"Error initializing user\",\n                ) !== null\n        );\n}\n\nasync function updateUserProgress(userId, guildId, data) {\n        return (\n                safeop(\n                        () =>\n                                new Promise((resolve, reject) => {\n                                        db.run(\n                                                \"UPDATE user_progress SET level = ?, points = ?, hint_used = ? WHERE user_id = ? AND guild_id = ?\",\n                                                [\n                                                        data.level,\n                                                        data.points,\n                                                        JSON.stringify(data.hintUsed),\n                                                        userId,\n                                                        guildId,\n                                                ],\n                                                (err) => {\n                                                        if (err) reject(err);\n                                                        else resolve(true);\n                                                },\n                                        );\n                                }),\n                        \"Error updating user progress\",\n                ) !== null\n        );\n}\n\nasync function getLeaderboard(guildId, limit = 100) {\n        await ensureLeaderboardTable();\n        return new Promise((resolve, reject) => {\n                db.all(\n                        \"SELECT * FROM leaderboard WHERE guild_id = ? ORDER BY points DESC, last_completed ASC LIMIT ?\",\n                        [guildId, limit],\n                        (err, rows) => {\n                                if (err) reject(err);\n                                resolve(rows || []);\n                        },\n                );\n        });\n}\n\nasync function updateLeaderboard(guildId, data) {\n        await ensureLeaderboardTable();\n        return new Promise((resolve, reject) => {\n                db.run(\n                        `INSERT INTO leaderboard (user_id, guild_id, username, points, level, start_time, last_completed)\n                         VALUES (?, ?, ?, ?, ?, ?, ?)\n                         ON CONFLICT(user_id, guild_id) DO UPDATE SET \n                         points = ?, level = ?, last_completed = ?`,\n                        [\n                                data.userId,\n                                guildId,\n                                data.username,\n                                data.points,\n                                data.level,\n                                data.startTime,\n                                data.lastCompleted,\n                                data.points,\n                                data.level,\n                                data.lastCompleted,\n                        ],\n                        (err) => {\n                                if (err) reject(err);\n                                resolve();\n                        },\n                );\n        });\n}\n\nasync function getUserRank(userId, guildId) {\n        await ensureLeaderboardTable();\n        return new Promise((resolve, reject) => {\n                db.get(\n                        `SELECT COUNT(*) + 1 as rank FROM leaderboard \n                         WHERE guild_id = ? AND points > (SELECT points FROM leaderboard WHERE user_id = ? AND guild_id = ?)`,\n                        [guildId, userId, guildId],\n                        (err, row) => {\n                                if (err) {\n                                        console.error(\"Error getting user rank:\", err);\n                                        resolve(null);\n                                        return;\n                                }\n                                resolve(row ? row.rank : null);\n                        },\n                );\n        });\n}\n\nasync function getCompletedLevels(userId, guildId) {\n        return new Promise((resolve, reject) => {\n                db.all(\n                        \"SELECT * FROM completed_levels WHERE user_id = ? AND guild_id = ? ORDER BY completed_at ASC\",\n                        [userId, guildId],\n                        (err, rows) => {\n                                if (err) {\n                                        console.error(\"Error getting completed levels:\", err);\n                                        resolve([]);\n                                        return;\n                                }\n                                resolve(rows || []);\n                        },\n                );\n        });\n}\n\nasync function recordCompletedLevel(userId, guildId, levelId, completedAt, pointsEarned) {\n        return new Promise((resolve, reject) => {\n                db.run(\n                        \"INSERT INTO completed_levels (user_id, guild_id, level_id, completed_at, points_earned) VALUES (?, ?, ?, ?, ?)\",\n                        [userId, guildId, levelId, completedAt, pointsEarned],\n                        (err) => {\n                                if (err) {\n                                        console.error(\"Error recording completed level:\", err);\n                                        resolve(false);\n                                        return;\n                                }\n                                resolve(true);\n                        },\n                );\n        });\n}\n\nmodule.exports = {\n        getGuildHunt,\n        createGuildHunt,\n        deleteGuildHunt,\n        getUserProgress,\n        initializeUser,\n        updateUserProgress,\n        getLeaderboard,\n        updateLeaderboard,\n        getUserRank,\n        getCompletedLevels,\n        recordCompletedLevel,\n        cleanupDatabaseState,\n};\n","path":null,"size_bytes":21804,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/src/client.js":{"content":"const { Client, GatewayIntentBits } = require(\"discord.js\");\n\nconst client = new Client({\n        intents: [\n                GatewayIntentBits.Guilds,\n                GatewayIntentBits.GuildMessages,\n                GatewayIntentBits.MessageContent,\n        ],\n});\n\nmodule.exports = client;\n","path":null,"size_bytes":291,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/src/handlers/messageHandler.js":{"content":"const { EmbedBuilder } = require(\"discord.js\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst { PREFIX } = require(\"../config\");\nconst { isAllowedOwner } = require(\"../utils/permissions\");\nconst { getGuildHunt, getUserProgress, updateUserProgress, updateLeaderboard, getLeaderboard, deleteGuildHunt } = require(\"../database/operations\");\nconst leadExamples = require(\"../data/leadExamples\");\n\nfunction loadFunQuestions() {\n        const filePath = path.join(__dirname, \"../../fun-questions.json\");\n        try {\n                const data = fs.readFileSync(filePath, \"utf8\");\n                return JSON.parse(data);\n        } catch (error) {\n                console.error(\"Error loading fun-questions.json:\", error);\n                return null;\n        }\n}\n\nasync function handleMessage(message) {\n        if (message.author.bot) return;\n\n        const content = message.content.toLowerCase();\n        if (!content.startsWith(PREFIX.toLowerCase())) return;\n\n        if (!isAllowedOwner(message.author.id)) {\n                return;\n        }\n\n        const args = message.content.slice(PREFIX.length).trim().split(/\\s+/);\n        const command = args.shift()?.toLowerCase();\n        const guildId = message.guild?.id;\n\n        if (!guildId) {\n                return message.reply(\"This command can only be used in servers.\");\n        }\n\n        try {\n                switch (command) {\n                        case \"help\":\n                                return handleHelp(message);\n\n                        case \"answers\":\n                                return handleAnswers(message, guildId);\n\n                        case \"leads\":\n                                return handleLeads(message);\n\n                        case \"fun\":\n                                return handleFun(message, args);\n\n                        case \"funanswer\":\n                                return handleFunAnswer(message, args);\n\n                        case \"add\":\n                                return handleAddPoints(message, args, guildId);\n\n                        case \"remove\":\n                                return handleRemovePoints(message, args, guildId);\n\n                        case \"end\":\n                                return handleEnd(message, guildId);\n\n                        default:\n                                await message.reply(`Unknown command. Use \\`${PREFIX}help\\` to see available commands.`);\n                }\n        } catch (error) {\n                console.error(\"Error handling prefix command:\", error);\n                await message.reply(\"An error occurred while processing the command.\");\n        }\n}\n\nasync function handleHelp(message) {\n        const helpEmbed = new EmbedBuilder()\n                .setColor(0x9B59B6)\n                .setTitle(\"üîê KryptixBot Owner Commands\")\n                .setDescription(\"These commands are only available to authorized owners/admins.\")\n                .addFields(\n                        {\n                                name: \"üìã Available Commands\",\n                                value: [\n                                        \"`khelp` - Show this help message\",\n                                        \"`kanswers` - View all hunt questions and answers\",\n                                        \"`kleads` - Learn how to give leads to contestants\",\n                                        \"`kfun` - Show a random fun challenge\",\n                                        \"`kfun <id>` - Show a specific fun challenge by ID\",\n                                        \"`kfun @user` - Show a fun challenge for a specific user\",\n                                        \"`kfunanswer` - View all fun question answers\",\n                                        \"`kfunanswer <id>` - View answer for specific question\",\n                                        \"`kadd <points> @user` - Add points to a user\",\n                                        \"`kremove <points> @user` - Remove points from a user\",\n                                        \"`kend` - End the hunt and show final results (Admin only)\"\n                                ].join(\"\\n\")\n                        },\n                        {\n                                name: \"‚ö†Ô∏è Important Notes\",\n                                value: [\n                                        \"‚Ä¢ All commands use prefix `k` or `K`\",\n                                        \"‚Ä¢ Only authorized owners can use these\",\n                                        \"‚Ä¢ Use `kanswers` and `kfunanswer` carefully - don't spoil!\",\n                                        \"‚Ä¢ Edit `fun-questions.json` to add/modify fun challenges\",\n                                        \"‚Ä¢ `kend` can only be used by the main admin\"\n                                ].join(\"\\n\")\n                        }\n                )\n                .setFooter({ text: \"Kryptix2k25 - Owner Panel\" })\n                .setTimestamp();\n\n        await message.reply({ embeds: [helpEmbed] });\n}\n\nasync function handleAnswers(message, guildId) {\n        const guildHunt = await getGuildHunt(guildId);\n\n        if (!guildHunt) {\n                return message.reply(\"‚ùå No active hunt found in this server. Use `/setup-hunt` first.\");\n        }\n\n        const huntData = guildHunt.huntData;\n        const answersEmbed = new EmbedBuilder()\n                .setColor(0xE74C3C)\n                .setTitle(`üîë ${huntData.name} - All Answers`)\n                .setDescription(\"**‚ö†Ô∏è CONFIDENTIAL - Do not share with contestants!**\")\n                .setFooter({ text: \"Kryptix2k25 - Answer Key\" })\n                .setTimestamp();\n\n        let answersList = \"\";\n        for (const level of huntData.levels) {\n                const answers = Array.isArray(level.answer) ? level.answer.join(\", \") : level.answer;\n                answersList += `**Level ${level.id}** (${level.points} pts)\\n`;\n                answersList += `Q: ${level.question.substring(0, 50)}${level.question.length > 50 ? \"...\" : \"\"}\\n`;\n                answersList += `A: \\`${answers}\\`\\n\\n`;\n        }\n\n        if (answersList.length > 4000) {\n                const chunks = [];\n                let currentChunk = \"\";\n                const lines = answersList.split(\"\\n\\n\");\n\n                for (const line of lines) {\n                        if ((currentChunk + line + \"\\n\\n\").length > 1900) {\n                                chunks.push(currentChunk);\n                                currentChunk = line + \"\\n\\n\";\n                        } else {\n                                currentChunk += line + \"\\n\\n\";\n                        }\n                }\n                if (currentChunk) chunks.push(currentChunk);\n\n                await message.reply({ embeds: [answersEmbed] });\n                for (let i = 0; i < chunks.length; i++) {\n                        const chunkEmbed = new EmbedBuilder()\n                                .setColor(0xE74C3C)\n                                .setTitle(`üìÑ Answers (Part ${i + 1}/${chunks.length})`)\n                                .setDescription(chunks[i]);\n                        await message.channel.send({ embeds: [chunkEmbed] });\n                }\n        } else {\n                answersEmbed.setDescription(\"**‚ö†Ô∏è CONFIDENTIAL - Do not share with contestants!**\\n\\n\" + answersList);\n                await message.reply({ embeds: [answersEmbed] });\n        }\n}\n\nasync function handleLeads(message) {\n        const leadsEmbed = new EmbedBuilder()\n                .setColor(0x3498DB)\n                .setTitle(\"üìç How to Give Leads to Contestants\")\n                .setDescription(\"Use these techniques to help stuck contestants without giving away answers directly.\")\n                .setFooter({ text: \"Kryptix2k25 - Lead Guide\" })\n                .setTimestamp();\n\n        for (const lead of leadExamples) {\n                leadsEmbed.addFields({\n                        name: `üí° ${lead.type}`,\n                        value: [\n                                `**What:** ${lead.description}`,\n                                `**Example:** \"${lead.example}\"`,\n                                `**When:** ${lead.when}`\n                        ].join(\"\\n\"),\n                        inline: false\n                });\n        }\n\n        leadsEmbed.addFields({\n                name: \"üéØ Pro Tips\",\n                value: [\n                        \"‚Ä¢ Start with subtle hints, escalate if needed\",\n                        \"‚Ä¢ Never give the exact answer directly\",\n                        \"‚Ä¢ Encourage them to think differently\",\n                        \"‚Ä¢ Use `kfun` to give them a chance to earn hints\",\n                        \"‚Ä¢ Remember: the goal is to guide, not solve\"\n                ].join(\"\\n\")\n        });\n\n        await message.reply({ embeds: [leadsEmbed] });\n}\n\nasync function handleFun(message, args) {\n        const funData = loadFunQuestions();\n        \n        if (!funData || !funData.questions || funData.questions.length === 0) {\n                return message.reply(\"‚ùå No fun questions found. Please check `fun-questions.json` file.\");\n        }\n\n        const mentionedUser = message.mentions.users.first();\n        const questionIdArg = args.find(arg => !arg.startsWith(\"<@\"));\n        \n        let question;\n        if (questionIdArg) {\n                const questionId = parseInt(questionIdArg);\n                question = funData.questions.find(q => q.id === questionId);\n                if (!question) {\n                        return message.reply(`‚ùå Question with ID ${questionId} not found. Available IDs: ${funData.questions.map(q => q.id).join(\", \")}`);\n                }\n        } else {\n                question = funData.questions[Math.floor(Math.random() * funData.questions.length)];\n        }\n\n        const points = question.points || funData.default_points || 100;\n\n        const funEmbed = new EmbedBuilder()\n                .setColor(0xF39C12)\n                .setTitle(`üéÆ Fun Challenge #${question.id}`)\n                .setDescription(mentionedUser ? `**Challenge for:** ${mentionedUser}` : \"Solve this challenge for bonus points!\")\n                .addFields(\n                        {\n                                name: \"üìù Question\",\n                                value: question.question\n                        },\n                        {\n                                name: \"üéÅ Reward\",\n                                value: `**${points} points** if answered correctly!`\n                        }\n                )\n                .setFooter({ text: `Use ${PREFIX}add ${points} @user to award points | Answer: hidden from staff` })\n                .setTimestamp();\n\n        await message.reply({ embeds: [funEmbed] });\n}\n\nasync function handleFunAnswer(message, args) {\n        const funData = loadFunQuestions();\n        \n        if (!funData || !funData.questions || funData.questions.length === 0) {\n                return message.reply(\"‚ùå No fun questions found. Please check `fun-questions.json` file.\");\n        }\n\n        if (args.length === 0) {\n                const allAnswers = funData.questions.map(q => {\n                        const answers = Array.isArray(q.answer) ? q.answer.join(\", \") : q.answer;\n                        return `**#${q.id}:** \\`${answers}\\``;\n                }).join(\"\\n\");\n\n                const answersEmbed = new EmbedBuilder()\n                        .setColor(0xE74C3C)\n                        .setTitle(\"üîë Fun Question Answers\")\n                        .setDescription(\"**‚ö†Ô∏è CONFIDENTIAL - Do not share!**\\n\\n\" + allAnswers)\n                        .setFooter({ text: \"Use kfunanswer <id> to see a specific answer\" })\n                        .setTimestamp();\n\n                return message.reply({ embeds: [answersEmbed] });\n        }\n\n        const questionId = parseInt(args[0]);\n        const question = funData.questions.find(q => q.id === questionId);\n        \n        if (!question) {\n                return message.reply(`‚ùå Question with ID ${questionId} not found. Available IDs: ${funData.questions.map(q => q.id).join(\", \")}`);\n        }\n\n        const answers = Array.isArray(question.answer) ? question.answer.join(\", \") : question.answer;\n        const points = question.points || funData.default_points || 100;\n\n        const answerEmbed = new EmbedBuilder()\n                .setColor(0xE74C3C)\n                .setTitle(`üîë Answer for Question #${question.id}`)\n                .setDescription(\"**‚ö†Ô∏è CONFIDENTIAL - Do not share!**\")\n                .addFields(\n                        {\n                                name: \"üìù Question\",\n                                value: question.question\n                        },\n                        {\n                                name: \"‚úÖ Accepted Answers\",\n                                value: `\\`${answers}\\``\n                        },\n                        {\n                                name: \"üí° Hint\",\n                                value: question.hint || \"No hint available\"\n                        },\n                        {\n                                name: \"üéÅ Points\",\n                                value: `${points}`\n                        }\n                )\n                .setFooter({ text: `Use ${PREFIX}add ${points} @user to award points` })\n                .setTimestamp();\n\n        await message.reply({ embeds: [answerEmbed] });\n}\n\nasync function handleAddPoints(message, args, guildId) {\n        const guildHunt = await getGuildHunt(guildId);\n        \n        if (!guildHunt) {\n                return message.reply(\"‚ùå No active hunt found in this server. Use `/setup-hunt` first.\");\n        }\n\n        if (args.length < 2) {\n                return message.reply(`‚ùå Usage: \\`${PREFIX}add <points> @user\\`\\nExample: \\`${PREFIX}add 50 @username\\``);\n        }\n\n        const pointsArg = args[0];\n        const points = parseInt(pointsArg);\n\n        if (isNaN(points)) {\n                return message.reply(`‚ùå Invalid points amount. Please provide a number.\\nUsage: \\`${PREFIX}add <points> @user\\``);\n        }\n\n        const mentionedUser = message.mentions.users.first();\n        if (!mentionedUser) {\n                return message.reply(`‚ùå Please mention a user.\\nUsage: \\`${PREFIX}add <points> @user\\``);\n        }\n\n        if (mentionedUser.bot) {\n                return message.reply(\"‚ùå You cannot add points to a bot!\");\n        }\n\n        try {\n                const userState = await getUserProgress(mentionedUser.id, guildId);\n                \n                if (!userState) {\n                        return message.reply(`‚ùå ${mentionedUser} hasn't started the hunt yet. They need to use \\`/hunt\\` first.`);\n                }\n\n                const oldPoints = userState.points;\n                userState.points += points;\n\n                if (userState.points < 0) {\n                        userState.points = 0;\n                }\n\n                await updateUserProgress(mentionedUser.id, guildId, userState);\n\n                await updateLeaderboard(guildId, {\n                        userId: mentionedUser.id,\n                        username: mentionedUser.username,\n                        points: userState.points,\n                        level: userState.level,\n                        startTime: userState.startTime,\n                        lastCompleted: Date.now(),\n                });\n\n                const actionWord = points >= 0 ? \"added to\" : \"removed from\";\n                const pointsDisplay = Math.abs(points);\n\n                const successEmbed = new EmbedBuilder()\n                        .setColor(points >= 0 ? 0x2ECC71 : 0xE74C3C)\n                        .setTitle(points >= 0 ? \"‚úÖ Points Added\" : \"‚ûñ Points Removed\")\n                        .setDescription(`**${pointsDisplay} points** ${actionWord} ${mentionedUser}`)\n                        .addFields(\n                                { name: \"Previous Points\", value: `${oldPoints}`, inline: true },\n                                { name: \"New Points\", value: `${userState.points}`, inline: true },\n                                { name: \"Change\", value: `${points >= 0 ? \"+\" : \"\"}${points}`, inline: true }\n                        )\n                        .setFooter({ text: `Modified by ${message.author.username}` })\n                        .setTimestamp();\n\n                await message.reply({ embeds: [successEmbed] });\n\n        } catch (error) {\n                console.error(\"Error adding points:\", error);\n                await message.reply(\"‚ùå An error occurred while adding points. Please try again.\");\n        }\n}\n\nasync function handleRemovePoints(message, args, guildId) {\n        const guildHunt = await getGuildHunt(guildId);\n        \n        if (!guildHunt) {\n                return message.reply(\"‚ùå No active hunt found in this server. Use `/setup-hunt` first.\");\n        }\n\n        if (args.length < 2) {\n                return message.reply(`‚ùå Usage: \\`${PREFIX}remove <points> @user\\`\\nExample: \\`${PREFIX}remove 50 @username\\``);\n        }\n\n        const pointsArg = args[0];\n        const points = parseInt(pointsArg);\n\n        if (isNaN(points) || points <= 0) {\n                return message.reply(`‚ùå Invalid points amount. Please provide a positive number.\\nUsage: \\`${PREFIX}remove <points> @user\\``);\n        }\n\n        const mentionedUser = message.mentions.users.first();\n        if (!mentionedUser) {\n                return message.reply(`‚ùå Please mention a user.\\nUsage: \\`${PREFIX}remove <points> @user\\``);\n        }\n\n        if (mentionedUser.bot) {\n                return message.reply(\"‚ùå You cannot remove points from a bot!\");\n        }\n\n        try {\n                const userState = await getUserProgress(mentionedUser.id, guildId);\n                \n                if (!userState) {\n                        return message.reply(`‚ùå ${mentionedUser} hasn't started the hunt yet. They need to use \\`/hunt\\` first.`);\n                }\n\n                const oldPoints = userState.points;\n                userState.points -= points;\n\n                if (userState.points < 0) {\n                        userState.points = 0;\n                }\n\n                await updateUserProgress(mentionedUser.id, guildId, userState);\n\n                await updateLeaderboard(guildId, {\n                        userId: mentionedUser.id,\n                        username: mentionedUser.username,\n                        points: userState.points,\n                        level: userState.level,\n                        startTime: userState.startTime,\n                        lastCompleted: Date.now(),\n                });\n\n                const successEmbed = new EmbedBuilder()\n                        .setColor(0xE74C3C)\n                        .setTitle(\"‚ûñ Points Removed\")\n                        .setDescription(`**${points} points** removed from ${mentionedUser}`)\n                        .addFields(\n                                { name: \"Previous Points\", value: `${oldPoints}`, inline: true },\n                                { name: \"New Points\", value: `${userState.points}`, inline: true },\n                                { name: \"Change\", value: `-${points}`, inline: true }\n                        )\n                        .setFooter({ text: `Modified by ${message.author.username}` })\n                        .setTimestamp();\n\n                await message.reply({ embeds: [successEmbed] });\n\n        } catch (error) {\n                console.error(\"Error removing points:\", error);\n                await message.reply(\"‚ùå An error occurred while removing points. Please try again.\");\n        }\n}\n\nconst MAIN_ADMIN_ID = \"952838363587706880\";\n\nasync function handleEnd(message, guildId) {\n        if (message.author.id !== MAIN_ADMIN_ID) {\n                return message.reply(\"‚ùå Only the main admin can use this command.\");\n        }\n\n        const guildHunt = await getGuildHunt(guildId);\n        \n        if (!guildHunt) {\n                return message.reply(\"‚ùå No active hunt found in this server.\");\n        }\n\n        try {\n                const leaderboard = await getLeaderboard(guildId);\n                const huntData = guildHunt.huntData;\n\n                const endEmbed = new EmbedBuilder()\n                        .setColor(0xFFD700)\n                        .setTitle(`üèÜ ${huntData.name} - HUNT ENDED!`)\n                        .setDescription(\"**The hunt has officially ended! Here are the final results:**\")\n                        .setTimestamp();\n\n                if (leaderboard && leaderboard.length > 0) {\n                        const sortedLeaderboard = leaderboard.sort((a, b) => {\n                                if (b.points !== a.points) return b.points - a.points;\n                                return (a.last_completed || 0) - (b.last_completed || 0);\n                        });\n\n                        const medals = [\"ü•á\", \"ü•à\", \"ü•â\"];\n                        let rankingText = \"\";\n\n                        for (let i = 0; i < Math.min(sortedLeaderboard.length, 10); i++) {\n                                const entry = sortedLeaderboard[i];\n                                const medal = medals[i] || `**#${i + 1}**`;\n                                const displayName = entry.username || `User`;\n                                const completedLevel = Math.max(0, (entry.level || 1) - 1);\n                                rankingText += `${medal} <@${entry.user_id}> (${displayName}) - **${entry.points || 0} points** (Level ${completedLevel})\\n`;\n                        }\n\n                        endEmbed.addFields({\n                                name: \"üèÖ Final Leaderboard\",\n                                value: rankingText || \"No participants\"\n                        });\n\n                        if (sortedLeaderboard.length > 0) {\n                                const winner = sortedLeaderboard[0];\n                                endEmbed.addFields({\n                                        name: \"üëë Winner\",\n                                        value: `Congratulations to <@${winner.user_id}> for winning with **${winner.points || 0} points**!`\n                                });\n                        }\n\n                        endEmbed.addFields({\n                                name: \"üìä Statistics\",\n                                value: `Total Participants: **${sortedLeaderboard.length}**\\nTotal Levels: **${huntData.levels.length}**`\n                        });\n                } else {\n                        endEmbed.addFields({\n                                name: \"üìä Results\",\n                                value: \"No participants completed any levels.\"\n                        });\n                }\n\n                await message.channel.send({ embeds: [endEmbed] });\n\n                await deleteGuildHunt(guildId);\n\n                const confirmEmbed = new EmbedBuilder()\n                        .setColor(0x2ECC71)\n                        .setTitle(\"‚úÖ Hunt Ended Successfully\")\n                        .setDescription(\"The hunt has been ended and all progress has been cleared.\\nUse `/setup-hunt` to start a new hunt.\")\n                        .setTimestamp();\n\n                await message.reply({ embeds: [confirmEmbed] });\n\n        } catch (error) {\n                console.error(\"Error ending hunt:\", error);\n                await message.reply(\"‚ùå An error occurred while ending the hunt. Please try again.\");\n        }\n}\n\nmodule.exports = { handleMessage };\n","path":null,"size_bytes":23520,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/src/config/index.js":{"content":"require(\"dotenv\").config();\nconst ownersData = require(\"./owners.json\");\n\nconst ALLOWED_OWNER_IDS = ownersData.owners.map(owner => owner.id);\n\nconst PREFIX = \"k\";\n\nconsole.log(`Loaded ${ALLOWED_OWNER_IDS.length} owner IDs:`, ALLOWED_OWNER_IDS);\n\nmodule.exports = {\n        ALLOWED_OWNER_IDS,\n        PREFIX,\n        DISCORD_TOKEN: process.env.DISCORD_TOKEN,\n};\n","path":null,"size_bytes":361,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/readme.md":{"content":"# KryptixBot - Discord Cryptic Hunt Bot \n\n> A discord bot letting anyone run a cryptic hunt in their server\n\n##  What is KryptixBot?\n\nKryptixBot is a Discord bot designed for Kryptix2k25 that lets server admins create custom cryptic hunts for their servers. This includes common hunt features like hints and leaderboards and point system. Code can be customized for different types of hunts though it's good practice to use cdn links for images and links in questions to ensure they are accessible to all players.\n\n> Built for Kryptix2k25 event with features like hints, progress tracking, and leaderboard system. This version supports multi-server deployment so the bot can run in multiple Discord servers simultaneously.\n\n## Features\n- Make your own hunt with easy to use JSON format (easy to format with an llm)\n- support for hints & images\n- Leaderboard tracking based on points\n- admin suite for managing hunts\n- statistical tracking for players\n- takes 1/2 minutes to selfhost \n- literally sqlite so no need for a database server\n\n## üöÄ Getting Started\n\n### Prerequisites\n- Node.js (v16 or higher)\n- A Discord bot \n\n### Installation\n1. Clone this repository\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n3. Create a .env file with your bot token:\n   ```bash\n   DISCORD_TOKEN= GET FROM https://discord.com/developers/applications\n   ```\n4. Start the bot:\n   ```bash\n   node index.js\n   ```\n\n### Setting Up Your First Hunt\n\n1. **Create your hunt file** - Check out `example-hunt.json` for reference\n2. **Upload it** - Use `/setup-hunt` and attach your JSON file\n3. **Start hunting** -  Use `/hunt` to start hunting\n\n## üìù Commands\n\n### Player Commands\n- `/hunt` - current question starter\n- `/answer <solution>` - submit answer\n- `/hint` - Get a hint (20% points cut tho)\n- `/progress` - Check your progress and stats\n- `/leaderboard` - Check top 15 hunters\n- `/previous` - Review your completed questions\n- `/help` - Get help and command info\n\n### Admin Commands\n- `/setup-hunt` - Upload a new hunt file \n- `/hunt-status` - Check if a hunt is active in your server\n- `delete-hunt` - Delete the current hunt\n\n## üéÆ Creating Hunt Files\n\nHunt files are JSON documents that define your cryptic hunt. Here's the basic structure:\n\n```json\n{\n  \"name\": \"cIcAdA \",\n  \"description\": \"3301\",\n  \"levels\": [\n    {\n      \"id\": 1,\n      \"question\": \"hE WHO FOUND IT\",\n      \"answer\": [\"keyboard\", \"a keyboard\"],\n      \"hint\": \"You use it to type\",\n      \"points\": 100,\n      \"image\": \"https://example.com/image.jpg\"\n    }\n  ]\n}\n```\n\n### Required Fields\n- `name`: Hunts name\n- `levels`: Array of level objects\n- `id`: Id for each level (must be unique)\n- `question`: The provided starter\n- `answer`: String or array of answers (case-insensitive)\n\n### Optional Fields\n- `description`: Hunt description (useful for context)\n- `hint`: A helpful hint for the level (optional for each lvl)\n- `points`: The points for tha question (by default 100)\n- `image`: Incase you want to add an image directly. Or use a cdn link \n\n## Scoring -\nThe admin set's a questions point value and players can earn points by answering correctly.Using a hint takes away 20% of that (eg if a question is worth 100 points, using a hint will reduce the score to 80 points).Leaderboard shows the top 15 players based on points earned.\nImo this is better than prior approaches used where number of questions was taken into account for lb which caused too many ties.\n\n\n\n\n## üîß Troubleshooting / Common Issues\n\n**Bot not responding?**\n- Check your bot token is correct\n- Ensure the bot has proper permissions in your server\n- Verify the `data` folder exists\n\n**Hunt upload failing?**\n- Validate your JSON syntax\n- Check all required fields are present\n- Ensure file size is under 1MB\n\n**Database errors?**\n- Make sure the `data` folder is writable\n- Restart the bot to trigger database migration\n- try deleting the `data/hunt.db` file to reset the database (this will delete all hunt data)\n\n### License\nThis project is licensed under the GNU AGPLV3 License - see the [LICENSE](LICENSE) file for details.\n","path":null,"size_bytes":4079,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/src/database/connection.js":{"content":"const sqlite3 = require(\"sqlite3\").verbose();\nconst path = require(\"node:path\");\n\nconst db = new sqlite3.Database(\n        path.join(__dirname, \"..\", \"..\", \"data\", \"hunt.db\"),\n        sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE,\n        (err) => {\n                if (err) {\n                        console.error(\"db connection error:\", err);\n                        process.exit(1);\n                }\n                console.log(\"Connected to database\");\n        },\n);\n\nfunction createTables() {\n        const tables = [\n                {\n                        name: \"guild_hunts\",\n                        sql: `CREATE TABLE IF NOT EXISTS guild_hunts (\n                                guild_id TEXT PRIMARY KEY,\n                                hunt_data TEXT,\n                                created_by TEXT,\n                                created_at INTEGER,\n                                active INTEGER DEFAULT 1\n                        )`,\n                },\n                {\n                        name: \"user_progress\",\n                        sql: `CREATE TABLE IF NOT EXISTS user_progress (\n                                user_id TEXT,\n                                guild_id TEXT,\n                                level INTEGER,\n                                points INTEGER,\n                                hint_used TEXT,\n                                start_time INTEGER,\n                                PRIMARY KEY (user_id, guild_id)\n                        )`,\n                },\n                {\n                        name: \"completed_levels\",\n                        sql: `CREATE TABLE IF NOT EXISTS completed_levels (\n                                user_id TEXT,\n                                guild_id TEXT,\n                                level_id INTEGER,\n                                completed_at INTEGER,\n                                points_earned INTEGER,\n                                FOREIGN KEY(user_id, guild_id) REFERENCES user_progress(user_id, guild_id)\n                        )`,\n                },\n                {\n                        name: \"leaderboard\",\n                        sql: `CREATE TABLE IF NOT EXISTS leaderboard (\n                                user_id TEXT,\n                                guild_id TEXT,\n                                username TEXT,\n                                points INTEGER,\n                                level INTEGER,\n                                start_time INTEGER,\n                                last_completed INTEGER,\n                                PRIMARY KEY (user_id, guild_id),\n                                FOREIGN KEY(user_id, guild_id) REFERENCES user_progress(user_id, guild_id)\n                        )`,\n                },\n        ];\n\n        const createTableSequentially = (index) => {\n                if (index >= tables.length) {\n                        console.log(\"All database tables created/updated successfully\");\n                        return;\n                }\n\n                const table = tables[index];\n                db.run(table.sql, (err) => {\n                        if (err) {\n                                console.error(`Error creating table ${table.name}:`, err);\n                        } else {\n                                console.log(`Table ${table.name} created/verified successfully`);\n                        }\n                        createTableSequentially(index + 1);\n                });\n        };\n\n        createTableSequentially(0);\n}\n\nfunction initializeDatabase() {\n        db.serialize(() => {\n                db.all(\"SELECT name FROM sqlite_master WHERE type='table'\", (err, tables) => {\n                        if (err) {\n                                console.error(\"Error checking existing tables:\", err);\n                                createTables();\n                                return;\n                        }\n\n                        const tableNames = tables.map((t) => t.name);\n                        const requiredTables = [\n                                \"guild_hunts\",\n                                \"user_progress\",\n                                \"completed_levels\",\n                                \"leaderboard\",\n                        ];\n                        const missingTables = requiredTables.filter(\n                                (table) => !tableNames.includes(table),\n                        );\n\n                        if (missingTables.length > 0) {\n                                console.log(\n                                        `Missing tables: ${missingTables.join(\", \")}, creating all tables...`,\n                                );\n                                createTables();\n                                return;\n                        }\n\n                        db.get(\"PRAGMA table_info(user_progress)\", (err, row) => {\n                                if (err) {\n                                        console.error(\"Error checking user_progress structure:\", err);\n                                        createTables();\n                                        return;\n                                }\n\n                                if (row && !tableNames.some((name) => name.includes(\"backup\"))) {\n                                        db.all(\"PRAGMA table_info(user_progress)\", (err, columns) => {\n                                                if (err) {\n                                                        console.error(\"Error getting user_progress columns:\", err);\n                                                        createTables();\n                                                        return;\n                                                }\n\n                                                const hasGuildId = columns.some((col) => col.name === \"guild_id\");\n\n                                                if (!hasGuildId) {\n                                                        console.log(\n                                                                \"Migrating existing database to multi-server format...\",\n                                                        );\n\n                                                        db.run(\"DROP TABLE IF EXISTS user_progress_backup\");\n                                                        db.run(\"DROP TABLE IF EXISTS completed_levels_backup\");\n                                                        db.run(\"DROP TABLE IF EXISTS leaderboard_backup\");\n\n                                                        setTimeout(() => {\n                                                                db.run(\n                                                                        \"ALTER TABLE user_progress RENAME TO user_progress_backup\",\n                                                                        (err) => {\n                                                                                if (err) {\n                                                                                        console.error(\"Error backing up user_progress:\", err);\n                                                                                        createTables();\n                                                                                        return;\n                                                                                }\n\n                                                                                db.run(\n                                                                                        \"ALTER TABLE completed_levels RENAME TO completed_levels_backup\",\n                                                                                        (err) => {\n                                                                                                if (err)\n                                                                                                        console.error(\n                                                                                                                \"Error backing up completed_levels:\",\n                                                                                                                err,\n                                                                                                        );\n                                                                                        },\n                                                                                );\n\n                                                                                db.run(\n                                                                                        \"ALTER TABLE leaderboard RENAME TO leaderboard_backup\",\n                                                                                        (err) => {\n                                                                                                if (err)\n                                                                                                        console.error(\"Error backing up leaderboard:\", err);\n                                                                                        },\n                                                                                );\n\n                                                                                createTables();\n                                                                        },\n                                                                );\n                                                        }, 100);\n                                                } else {\n                                                        console.log(\"Database tables are in correct format, verifying...\");\n                                                        createTables();\n                                                }\n                                        });\n                                } else {\n                                        console.log(\n                                                \"Database appears to be in correct state, verifying tables...\",\n                                        );\n                                        createTables();\n                                }\n                        });\n                });\n        });\n}\n\nfunction closeDatabase() {\n        return new Promise((resolve, reject) => {\n                db.close((err) => {\n                        if (err) {\n                                console.error(\"Error closing database:\", err);\n                                reject(err);\n                        } else {\n                                console.log(\"Database connection closed\");\n                                resolve();\n                        }\n                });\n        });\n}\n\nmodule.exports = {\n        db,\n        initializeDatabase,\n        createTables,\n        closeDatabase,\n};\n","path":null,"size_bytes":10869,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/src/data/funActivities.js":{"content":"const funActivities = [\n        {\n                title: \"Trivia Challenge\",\n                description: \"Answer this trivia question correctly to earn a hint!\",\n                task: \"What programming language was created by Guido van Rossum?\",\n                answer: [\"python\", \"Python\"],\n                reward: \"You've earned a free hint token! Use it wisely.\"\n        },\n        {\n                title: \"Speed Challenge\",\n                description: \"Type the following phrase exactly in the next 30 seconds:\",\n                task: \"Kryptix2k25 is the ultimate cryptic hunt!\",\n                answer: [\"Kryptix2k25 is the ultimate cryptic hunt!\"],\n                reward: \"Lightning fast! You've earned a hint boost.\"\n        },\n        {\n                title: \"Riddle Time\",\n                description: \"Solve this quick riddle:\",\n                task: \"What has hands but can't clap?\",\n                answer: [\"clock\", \"a clock\", \"Clock\", \"A clock\"],\n                reward: \"Brain power activated! Hint unlocked.\"\n        },\n        {\n                title: \"Math Sprint\",\n                description: \"Quick math! What's the answer?\",\n                task: \"What is 7 x 8 + 6?\",\n                answer: [\"62\"],\n                reward: \"Calculator brain! You've earned bonus points.\"\n        },\n        {\n                title: \"Emoji Decode\",\n                description: \"What word do these emojis represent?\",\n                task: \"üîë + üîê = ?\",\n                answer: [\"unlock\", \"key\", \"keylock\", \"security\"],\n                reward: \"Emoji master! Hint power-up granted.\"\n        },\n        {\n                title: \"Reverse Challenge\",\n                description: \"What word is this when reversed?\",\n                task: \"XITPYRK\",\n                answer: [\"kryptix\", \"KRYPTIX\", \"Kryptix\"],\n                reward: \"Mirror mind! You've unlocked a special hint.\"\n        },\n        {\n                title: \"Pattern Recognition\",\n                description: \"What comes next in this pattern?\",\n                task: \"A, C, E, G, __\",\n                answer: [\"I\", \"i\"],\n                reward: \"Pattern pro! Extra hint incoming.\"\n        },\n        {\n                title: \"Word Scramble\",\n                description: \"Unscramble this word:\",\n                task: \"TPRCICY\",\n                answer: [\"cryptic\", \"CRYPTIC\", \"Cryptic\"],\n                reward: \"Word wizard! Hint bonus earned.\"\n        }\n];\n\nmodule.exports = funActivities;\n","path":null,"size_bytes":2471,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/src/data/leadExamples.js":{"content":"const leadExamples = [\n        {\n                type: \"Subtle Hint\",\n                description: \"Give a vague direction without revealing the answer\",\n                example: \"Think about what you use every day to communicate digitally...\",\n                when: \"When contestants are completely stuck\"\n        },\n        {\n                type: \"Category Clue\",\n                description: \"Tell them what category the answer falls into\",\n                example: \"The answer is related to technology/nature/history...\",\n                when: \"When they're searching in the wrong direction\"\n        },\n        {\n                type: \"Letter Count\",\n                description: \"Reveal how many letters are in the answer\",\n                example: \"The answer has 8 letters\",\n                when: \"When they have ideas but need confirmation\"\n        },\n        {\n                type: \"First Letter\",\n                description: \"Give them the first letter of the answer\",\n                example: \"It starts with the letter 'K'\",\n                when: \"When they're very close but need a push\"\n        },\n        {\n                type: \"Elimination\",\n                description: \"Tell them what the answer is NOT\",\n                example: \"It's not a physical object you can touch\",\n                when: \"When they keep guessing wrong categories\"\n        },\n        {\n                type: \"Context Clue\",\n                description: \"Provide additional context around the question\",\n                example: \"Think about the theme of Kryptix2k25...\",\n                when: \"When they're not connecting the dots\"\n        },\n        {\n                type: \"Wordplay Hint\",\n                description: \"Point out any wordplay or double meanings\",\n                example: \"Pay attention to the words 'enter' and 'space' - they have multiple meanings\",\n                when: \"When the question uses puns or double meanings\"\n        }\n];\n\nmodule.exports = leadExamples;\n","path":null,"size_bytes":1983,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/src/utils/permissions.js":{"content":"const { ALLOWED_OWNER_IDS } = require(\"../config\");\n\nfunction isAllowedOwner(userId) {\n        return ALLOWED_OWNER_IDS.includes(userId);\n}\n\nfunction isServerOwner(interaction) {\n        return (\n                interaction.member.permissions.has(\"Administrator\") ||\n                interaction.guild.ownerId === interaction.user.id\n        );\n}\n\nfunction isWhitelistedChannel(channelId) {\n        return true;\n}\n\nmodule.exports = {\n        isAllowedOwner,\n        isServerOwner,\n        isWhitelistedChannel,\n};\n","path":null,"size_bytes":513,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/src/handlers/interactionHandler.js":{"content":"const { EmbedBuilder, MessageFlags } = require(\"discord.js\");\nconst { isServerOwner } = require(\"../utils/permissions\");\nconst { validateHuntData } = require(\"../utils/validation\");\nconst {\n        getGuildHunt,\n        createGuildHunt,\n        deleteGuildHunt,\n        getUserProgress,\n        updateUserProgress,\n        getLeaderboard,\n        updateLeaderboard,\n        getUserRank,\n        getCompletedLevels,\n        recordCompletedLevel,\n        cleanupDatabaseState,\n} = require(\"../database/operations\");\n\nasync function handleInteraction(interaction) {\n        if (interaction.isButton()) {\n                return handleButtonInteraction(interaction);\n        }\n        \n        if (!interaction.isCommand()) return;\n\n        try {\n                const { commandName } = interaction;\n                const userId = interaction.user.id;\n                const guildId = interaction.guild?.id;\n\n                if (!guildId) {\n                        return interaction.reply({\n                                content: \"This bot can only be used in servers, not in DMs.\",\n                                flags: MessageFlags.Ephemeral,\n                        });\n                }\n\n                if (![\"setup-hunt\", \"hunt-status\", \"help\", \"delete-hunt\"].includes(commandName)) {\n                        const guildHunt = await getGuildHunt(guildId);\n                        if (!guildHunt) {\n                                return interaction.reply({\n                                        content: \"No active hunt found in this server! Ask an admin to use `/setup-hunt` to create one.\",\n                                        flags: MessageFlags.Ephemeral,\n                                });\n                        }\n                }\n\n                const guildHunt = await getGuildHunt(guildId);\n                const huntData = guildHunt?.huntData;\n                const userState = huntData ? await getUserProgress(userId, guildId) : null;\n\n                switch (commandName) {\n                        case \"setup-hunt\":\n                                return handleSetupHunt(interaction, userId, guildId);\n\n                        case \"hunt-status\":\n                                return handleHuntStatus(interaction, guildId);\n\n                        case \"hunt\":\n                                return handleHunt(interaction, huntData, userState);\n\n                        case \"answer\":\n                                return handleAnswer(interaction, huntData, userState, userId, guildId);\n\n                        case \"leaderboard\":\n                                return handleLeaderboard(interaction, userId, guildId);\n\n                        case \"progress\":\n                                return handleProgress(interaction, huntData, userState, userId, guildId);\n\n                        case \"previous\":\n                                return handlePrevious(interaction, huntData, userId, guildId);\n\n                        case \"hint\":\n                                return handleHint(interaction, huntData, userState, userId, guildId);\n\n                        case \"delete-hunt\":\n                                return handleDeleteHunt(interaction, userId, guildId);\n\n                        case \"help\":\n                                return handleHelp(interaction);\n\n                        default:\n                                return interaction.reply({\n                                        content: \"Unknown command. Use `/help` for available commands.\",\n                                        flags: MessageFlags.Ephemeral,\n                                });\n                }\n        } catch (error) {\n                console.error(\"Error handling interaction:\", error);\n\n                const errorResponse = {\n                        content: \"An unexpected error occurred. Please try again later.\",\n                        flags: MessageFlags.Ephemeral,\n                };\n\n                if (interaction.deferred) {\n                        return interaction.editReply(errorResponse);\n                }\n                if (!interaction.replied) {\n                        return interaction.reply(errorResponse);\n                }\n        }\n}\n\nasync function handleSetupHunt(interaction, userId, guildId) {\n        if (!isServerOwner(interaction)) {\n                return interaction.reply({\n                        content: \"Only a server admin can setup hunts!\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        const attachment = interaction.options.getAttachment(\"hunt-file\");\n        if (!attachment) {\n                return interaction.reply({\n                        content: \"Please provide a valid json with your hunt questions\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        if (!attachment.name.endsWith(\".json\")) {\n                return interaction.reply({\n                        content: \"Please provide a valid JSON file\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        if (attachment.size > 1024 * 1024) {\n                return interaction.reply({\n                        content: \"File size too large! Maximum file size is 1MB.\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        try {\n                await interaction.deferReply({ ephemeral: false });\n\n                const response = await fetch(attachment.url);\n                if (!response.ok) {\n                        throw new Error(`Failed to fetch file: ${response.status}`);\n                }\n\n                const huntData = await response.json();\n\n                const validationErrors = validateHuntData(huntData);\n                if (validationErrors.length > 0) {\n                        const errorMessage = `**Invalid hunt data:**\\n${validationErrors.map((err) => `‚Ä¢ ${err}`).join(\"\\n\")}`;\n\n                        const exampleEmbed = new EmbedBuilder()\n                                .setTitle(\"Hunt Setup Failed\")\n                                .setColor(\"#FF0000\")\n                                .setDescription(errorMessage)\n                                .addFields({\n                                        name: \"üìã Required JSON Format\",\n                                        value: '```json\\n{\\n  \"name\": \"Hunt Name\",\\n  \"description\": \"Hunt description\",\\n  \"levels\": [\\n    {\\n      \"id\": 1,\\n      \"question\": \"Your question here\",\\n      \"answer\": \"answer\" or [\"answer1\", \"answer2\"],\\n      \"hint\": \"Optional hint\",\\n      \"points\": 100,\\n      \"image\": \"https://optional-image-url.com\"\\n    }\\n  ]\\n}\\n```',\n                                })\n                                .setFooter({\n                                        text: \"Check the example-hunt.json file for reference\",\n                                });\n\n                        return interaction.editReply({ embeds: [exampleEmbed] });\n                }\n\n                await cleanupDatabaseState();\n\n                const success = await createGuildHunt(guildId, huntData, userId);\n                if (!success) {\n                        return interaction.editReply({\n                                content: \"Failed to save hunt data. Please try again later.\",\n                        });\n                }\n\n                const embed = new EmbedBuilder()\n                        .setTitle(\"Hunt Setup Complete! üéâ\")\n                        .setColor(\"#00FF00\")\n                        .setDescription(\n                                `Successfully created \"${huntData.name}\" with ${huntData.levels.length} levels!`,\n                        )\n                        .addFields(\n                                { name: \"Created by\", value: `<@${userId}>` },\n                                { name: \"Total Levels\", value: huntData.levels.length.toString() },\n                                { name: \"Get Started\", value: \"Use `/hunt` to begin!\" },\n                        );\n\n                if (huntData.description) {\n                        embed.addFields({ name: \"Description\", value: huntData.description });\n                }\n\n                return interaction.editReply({ embeds: [embed] });\n        } catch (error) {\n                console.error(\"Error setting up hunt:\", error);\n                const errorEmbed = new EmbedBuilder()\n                        .setTitle(\"Hunt Setup Error\")\n                        .setColor(\"#FF0000\")\n                        .setDescription(\"Error processing hunt file. Please check the JSON format.\")\n                        .addFields({\n                                name: \"Common Issues\",\n                                value: \"‚Ä¢ Invalid JSON syntax\\n‚Ä¢ Missing required fields\\n‚Ä¢ File too large\\n‚Ä¢ Network error downloading file\",\n                        })\n                        .setFooter({\n                                text: \"Check the example-hunt.json file for reference(if you have selfhosted)\",\n                        });\n\n                return interaction.editReply({ embeds: [errorEmbed] });\n        }\n}\n\nasync function handleHuntStatus(interaction, guildId) {\n        const guildHunt = await getGuildHunt(guildId);\n\n        if (!guildHunt) {\n                const embed = new EmbedBuilder()\n                        .setTitle(\"No Active Hunt\")\n                        .setColor(\"#FF9900\")\n                        .setDescription(\"No active hunt in this server.\")\n                        .addFields({\n                                name: \"üìã Example Hunt Format\",\n                                value: '```json\\n{\\n  \"name\": \"Cicada\",\\n  \"description\": \"3301\",\\n  \"levels\": [\\n    {\\n      \"id\": 1,\\n      \"question\": \"Who am i \",\\n      \"answer\": [\"cicada\", \"a cicada\"],\\n      \"hint\": \"2013 ref\",\\n      \"points\": 100\\n    }\\n  ]\\n}\\n```',\n                        })\n                        .setFooter({ text: \"Use /setup-hunt to create one!\" });\n\n                return interaction.reply({\n                        embeds: [embed],\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        const embed = new EmbedBuilder()\n                .setTitle(\"Hunt Status\")\n                .setColor(\"#0099ff\")\n                .setDescription(`\"${guildHunt.huntData.name}\" is active in this server!`)\n                .addFields(\n                        { name: \"Total Levels\", value: guildHunt.huntData.levels.length.toString() },\n                        { name: \"Created by\", value: `<@${guildHunt.created_by}>` },\n                        { name: \"Created\", value: new Date(guildHunt.created_at).toLocaleDateString() },\n                );\n\n        if (guildHunt.huntData.description) {\n                embed.addFields({ name: \"Description\", value: guildHunt.huntData.description });\n        }\n\n        return interaction.reply({\n                embeds: [embed],\n                flags: MessageFlags.Ephemeral,\n        });\n}\n\nasync function handleHunt(interaction, huntData, userState) {\n        if (!userState) {\n                return interaction.reply({\n                        content: \"Failed to load your progress. Please try again later.\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        const currentLevel = huntData.levels.find((level) => level.id === userState.level);\n\n        if (!currentLevel) {\n                return interaction.reply({\n                        content: \"You have completed all levels! Congratulations! üéâ\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        const embed = new EmbedBuilder()\n                .setTitle(`Level ${currentLevel.id}`)\n                .setDescription(currentLevel.question)\n                .setColor(\"#0099ff\")\n                .setFooter({\n                        text: `Points: ${userState.points} | Good luck!`,\n                });\n\n        if (currentLevel.image) {\n                embed.setImage(currentLevel.image);\n        }\n\n        return interaction.reply({ embeds: [embed] });\n}\n\nasync function handleAnswer(interaction, huntData, userState, userId, guildId) {\n        if (!userState) {\n                return interaction.reply({\n                        content: \"Failed to load your progress. Please try again later.\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        const answer = interaction.options.getString(\"solution\")?.trim()?.toLowerCase();\n\n        if (!answer) {\n                return interaction.reply({\n                        content: \"Please provide a valid answer!\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        const currentLevel = huntData.levels.find((level) => level.id === userState.level);\n\n        if (!currentLevel) {\n                return interaction.reply({\n                        content: \"You have completed all levels! Congratulations! üéâ\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        const correctAnswer = Array.isArray(currentLevel.answer)\n                ? currentLevel.answer.map((a) => a.toLowerCase())\n                : [currentLevel.answer.toLowerCase()];\n\n        if (correctAnswer.includes(answer)) {\n                try {\n                        const levelPoints = currentLevel.points || 100;\n                        const pointsEarned = levelPoints;\n\n                        const completionTime = Date.now();\n\n                        userState.points += pointsEarned;\n                        userState.level++;\n\n                        await updateLeaderboard(guildId, {\n                                userId,\n                                username: interaction.user.username,\n                                points: userState.points,\n                                level: userState.level,\n                                startTime: userState.startTime,\n                                lastCompleted: completionTime,\n                        });\n\n                        const progressSaved = await updateUserProgress(userId, guildId, userState);\n                        if (!progressSaved) {\n                                console.error(\"Failed to save user progress\");\n                        }\n\n                        await recordCompletedLevel(userId, guildId, currentLevel.id, completionTime, pointsEarned);\n\n                        const nextLevel = huntData.levels.find((level) => level.id === userState.level);\n                        if (nextLevel) {\n                                return interaction.reply({\n                                        content: `üéâ ${interaction.user} earned ${pointsEarned} points and advanced to level ${nextLevel.id}!`,\n                                });\n                        }\n                        return interaction.reply({\n                                content: `üéâ ${interaction.user} has completed all levels with a total of ${userState.points} points! Congratulations! üèÜ`,\n                        });\n                } catch (error) {\n                        console.error(\"Error processing correct answer:\", error);\n                        return interaction.reply({\n                                content: \"An error occurred while processing your answer. Please try again.\",\n                                flags: MessageFlags.Ephemeral,\n                        });\n                }\n        }\n        return interaction.reply({\n                content: \"‚ùå Incorrect answer. Try again!\",\n                flags: MessageFlags.Ephemeral,\n        });\n}\n\nasync function handleLeaderboard(interaction, userId, guildId) {\n        try {\n                const leaderboardData = await getLeaderboard(guildId);\n                if (!leaderboardData || leaderboardData.length === 0) {\n                        return interaction.reply({\n                                content: \"No entries in the leaderboard yet!\",\n                        });\n                }\n\n                const embed = new EmbedBuilder()\n                        .setTitle(\"Cryptic Hunt Leaderboard\")\n                        .setColor(\"#FFD700\")\n                        .setDescription(\"Top 15 players by points\");\n\n                const topPlayers = leaderboardData.slice(0, 15);\n                const leaderboardText = topPlayers\n                        .map((entry, index) => {\n                                const username = entry.username;\n                                const level = entry.level - 1;\n                                const points = entry.points;\n\n                                const timeAgo = Math.floor((Date.now() - entry.last_completed) / 1000 / 60);\n                                const timeDisplay = timeAgo < 60\n                                        ? `${timeAgo}m ago`\n                                        : `${Math.floor(timeAgo / 60)}h ${timeAgo % 60}m ago`;\n\n                                return `**${index + 1}. ${username}** - Level ${level} - ${points} points (${timeDisplay})`;\n                        })\n                        .join(\"\\n\");\n\n                embed.setDescription(leaderboardText);\n\n                const userRank = leaderboardData.findIndex((entry) => entry.user_id === userId) + 1;\n                if (userRank > 0) {\n                        embed.setFooter({ text: `Your position: #${userRank}` });\n                }\n\n                return interaction.reply({ embeds: [embed] });\n        } catch (error) {\n                console.error(\"Error in leaderboard command:\", error);\n                return interaction.reply({\n                        content: \"An error occurred while fetching the leaderboard.\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n}\n\nasync function handleProgress(interaction, huntData, userState, userId, guildId) {\n        try {\n                const completedLevels = userState.level - 1;\n                const totalLevels = huntData.levels.length;\n                const progressPercent = Math.floor((completedLevels / totalLevels) * 100);\n\n                const userRank = await getUserRank(userId, guildId);\n                const completedLevelData = await getCompletedLevels(userId, guildId);\n\n                const embed = new EmbedBuilder()\n                        .setTitle(\"Your Hunt Progress\")\n                        .setColor(\"#00FF00\")\n                        .setDescription(`You are on Level ${userState.level} with ${userState.points} points`)\n                        .addFields(\n                                { name: \"Progress\", value: `${completedLevels}/${totalLevels} levels (${progressPercent}%)` },\n                                { name: \"Leaderboard Rank\", value: userRank ? `#${userRank}` : \"Not ranked yet\" },\n                        );\n\n                if (completedLevels > 0) {\n                        const firstLevel = completedLevelData[0];\n                        const lastLevel = completedLevelData[completedLevelData.length - 1];\n                        const totalTime = lastLevel.completed_at - firstLevel.completed_at;\n                        const avgMinutes = Math.floor(totalTime / 60000 / completedLevels);\n\n                        embed.addFields({ name: \"Average Time per Level\", value: `${avgMinutes} minutes` });\n                }\n\n                return interaction.reply({\n                        embeds: [embed],\n                        flags: MessageFlags.Ephemeral,\n                });\n        } catch (error) {\n                console.error(\"Error in progress command:\", error);\n                return interaction.reply({\n                        content: \"An error occurred while fetching your progress.\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n}\n\nasync function handlePrevious(interaction, huntData, userId, guildId) {\n        const completedLevels = await getCompletedLevels(userId, guildId);\n\n        if (completedLevels.length === 0) {\n                return interaction.reply({\n                        content: \"You haven't completed any levels yet!\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        const embed = new EmbedBuilder()\n                .setTitle(\"Your Completed Questions\")\n                .setColor(\"#0099ff\");\n\n        const questionsText = completedLevels\n                .map((level) => {\n                        const levelData = huntData.levels.find((l) => l.id === level.level_id);\n                        if (!levelData) return null;\n\n                        const completedAt = new Date(level.completed_at);\n                        return `**Level ${level.level_id}** (${level.points_earned} points)\\n${levelData.question}\\nCompleted: ${completedAt.toLocaleString()}\\n`;\n                })\n                .filter((text) => text !== null)\n                .join(\"\\n\");\n\n        embed.setDescription(questionsText);\n\n        return interaction.reply({\n                embeds: [embed],\n                flags: MessageFlags.Ephemeral,\n        });\n}\n\nasync function handleHint(interaction, huntData, userState, userId, guildId) {\n        const embed = new EmbedBuilder()\n                .setTitle(\"Nice Try! üòè\")\n                .setColor(\"#FF6B6B\")\n                .setDescription(\"You really thought there would be hints separately for each person?\")\n                .setFooter({ text: \"Figure it out yourself!\" })\n                .setTimestamp();\n\n        return interaction.reply({\n                embeds: [embed],\n                flags: MessageFlags.Ephemeral,\n        });\n}\n\nasync function handleButtonInteraction(interaction) {\n        return interaction.reply({\n                content: \"This button is no longer active.\",\n                flags: MessageFlags.Ephemeral,\n        });\n}\n\nasync function handleDeleteHunt(interaction, userId, guildId) {\n        if (!isServerOwner(interaction)) {\n                return interaction.reply({\n                        content: \"Only server admins can delete hunts!\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        const confirmDelete = interaction.options.getBoolean(\"confirm\");\n        if (!confirmDelete) {\n                return interaction.reply({\n                        content: \"You must confirm deletion by setting the confirm option to `True`. This action cannot be undone!\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        const guildHunt = await getGuildHunt(guildId);\n        if (!guildHunt) {\n                return interaction.reply({\n                        content: \"No active hunt found in this server to delete.\",\n                        flags: MessageFlags.Ephemeral,\n                });\n        }\n\n        try {\n                await interaction.deferReply({ ephemeral: false });\n\n                const success = await deleteGuildHunt(guildId);\n                if (!success) {\n                        return interaction.editReply({\n                                content: \"Failed to delete hunt data. Please try again later.\",\n                        });\n                }\n\n                const embed = new EmbedBuilder()\n                        .setTitle(\"Hunt Deleted Successfully! üóëÔ∏è\")\n                        .setColor(\"#FF6B6B\")\n                        .setDescription(`The hunt \"${guildHunt.huntData.name}\" has been completely removed from this server.`)\n                        .addFields(\n                                { name: \"Deleted by\", value: `<@${userId}>` },\n                                {\n                                        name: \"What was removed\",\n                                        value: \"‚Ä¢ Hunt configuration\\n‚Ä¢ All user progress\\n‚Ä¢ Leaderboard data\\n‚Ä¢ Completed levels history\",\n                                },\n                                { name: \"Next steps\", value: \"Use `/setup-hunt` to create a new hunt!\" },\n                        )\n                        .setFooter({ text: \"This action cannot be undone\" });\n\n                return interaction.editReply({ embeds: [embed] });\n        } catch (error) {\n                console.error(\"Error deleting hunt:\", error);\n                return interaction.editReply({\n                        content: \"An error occurred while deleting the hunt. Please try again later.\",\n                });\n        }\n}\n\nasync function handleHelp(interaction) {\n        const embed = new EmbedBuilder()\n                .setTitle(\"Cryptic Hunt Help\")\n                .setColor(\"#00FF00\")\n                .setDescription(\"Welcome to the Cryptic Hunt! Here's how to play:\")\n                .addFields(\n                        {\n                                name: \"üìù Player Commands\",\n                                value: [\n                                        \"`/hunt` - View your current question\",\n                                        \"`/answer <solution>` - Submit an answer\",\n                                        \"`/progress` - Check your progress\",\n                                        \"`/leaderboard` - View top players\",\n                                        \"`/previous` - View your solved questions\",\n                                ].join(\"\\n\"),\n                        },\n                        {\n                                name: \"‚öôÔ∏è Admin Commands\",\n                                value: [\n                                        \"`/setup-hunt` - Setup a new hunt (Admin only)\",\n                                        \"`/hunt-status` - Check if hunt is active\",\n                                        \"`/delete-hunt` - Delete hunt and all data (Admin only)\",\n                                ].join(\"\\n\"),\n                        },\n                        {\n                                name: \"üéÆ How to Play\",\n                                value: \"Solve puzzles to advance through levels. Each correct answer earns you points. Good luck!\",\n                        },\n                );\n\n        return interaction.reply({\n                embeds: [embed],\n                flags: MessageFlags.Ephemeral,\n        });\n}\n\nmodule.exports = { handleInteraction };\n","path":null,"size_bytes":26189,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/src/commands/definitions.js":{"content":"const { SlashCommandBuilder } = require(\"discord.js\");\n\nconst commands = [\n        new SlashCommandBuilder()\n                .setName(\"hunt\")\n                .setDescription(\"Get your current cryptic hunt question\"),\n\n        new SlashCommandBuilder()\n                .setName(\"answer\")\n                .setDescription(\"Submit an answer for your current level\")\n                .addStringOption((option) =>\n                        option\n                                .setName(\"solution\")\n                                .setDescription(\"Your answer\")\n                                .setRequired(true),\n                ),\n\n        new SlashCommandBuilder()\n                .setName(\"leaderboard\")\n                .setDescription(\"View the hunt leaderboard\"),\n\n        new SlashCommandBuilder()\n                .setName(\"progress\")\n                .setDescription(\"Check your hunt progress\"),\n\n        new SlashCommandBuilder()\n                .setName(\"hint\")\n                .setDescription(\"Request a hint for your current level\"),\n\n        new SlashCommandBuilder()\n                .setName(\"help\")\n                .setDescription(\"Get information about how to play the hunt\"),\n\n        new SlashCommandBuilder()\n                .setName(\"previous\")\n                .setDescription(\"View your previously completed questions\"),\n\n        new SlashCommandBuilder()\n                .setName(\"setup-hunt\")\n                .setDescription(\"Setup a new hunt for your server (Admin only)\")\n                .addAttachmentOption((option) =>\n                        option\n                                .setName(\"hunt-file\")\n                                .setDescription(\"JSON file containing hunt data\")\n                                .setRequired(true),\n                ),\n\n        new SlashCommandBuilder()\n                .setName(\"hunt-status\")\n                .setDescription(\"Check if a hunt is active in this server\"),\n\n        new SlashCommandBuilder()\n                .setName(\"delete-hunt\")\n                .setDescription(\"Delete the current hunt and all progress (Admin only)\")\n                .addBooleanOption((option) =>\n                        option\n                                .setName(\"confirm\")\n                                .setDescription(\"Confirm deletion - this cannot be undone!\")\n                                .setRequired(true),\n                ),\n];\n\nfunction registerCommands(client) {\n        client.guilds.cache.forEach(guild => {\n                guild.commands.set(commands)\n                        .then(() => console.log(`Slash commands registered for guild: ${guild.name}`))\n                        .catch(error => console.error(`Error registering commands for ${guild.name}:`, error));\n        });\n        console.log(\"Slash commands registered for all guilds (instant registration)\");\n}\n\nmodule.exports = {\n        commands,\n        registerCommands,\n};\n","path":null,"size_bytes":2900,"size_tokens":null},"nonononnonono/BOTCRYPTIC/kryptix/index.js":{"content":"const client = require(\"./src/client\");\nconst { DISCORD_TOKEN } = require(\"./src/config\");\nconst { initializeDatabase, closeDatabase } = require(\"./src/database/connection\");\nconst { registerCommands } = require(\"./src/commands/definitions\");\nconst { handleInteraction } = require(\"./src/handlers/interactionHandler\");\nconst { handleMessage } = require(\"./src/handlers/messageHandler\");\n\ninitializeDatabase();\n\nclient.once(\"ready\", () => {\n        console.log(`Logged in as ${client.user.tag}`);\n        registerCommands(client);\n});\n\nclient.on(\"interactionCreate\", handleInteraction);\nclient.on(\"messageCreate\", handleMessage);\n\nfunction cleanup() {\n        console.log(\"Cleaning up...\");\n        closeDatabase()\n                .then(() => process.exit(0))\n                .catch(() => process.exit(1));\n}\n\nprocess.on(\"SIGINT\", cleanup);\nprocess.on(\"SIGTERM\", cleanup);\nprocess.on(\"uncaughtException\", (error) => {\n        console.error(\"Uncaught exception:\", error);\n        cleanup();\n});\n\nclient.login(DISCORD_TOKEN);\n","path":null,"size_bytes":1023,"size_tokens":null}},"version":2}